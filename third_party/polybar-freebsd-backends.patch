diff --git a/include/utils/acpi.hpp b/include/utils/acpi.hpp
new file mode 100644
index 00000000..ed451f8a
--- /dev/null
+++ b/include/utils/acpi.hpp
@@ -0,0 +1,18 @@
+#pragma once
+
+#include <string>
+
+POLYBAR_NS
+
+namespace utils {
+  // Parse acpiconf -i 0 output and return percentage (0-100) or -1 on failure
+  int parse_acpiconf_percent(const std::string& out);
+
+  // Parse acpiconf -i 0 output and return state string: "charging", "discharging", "ac", or empty on unknown
+  std::string parse_acpiconf_state(const std::string& out);
+
+  // Parse apm -l output and return percentage or -1
+  int parse_apm_percent(const std::string& out);
+}
+
+POLYBAR_NS_END
diff --git a/src/CMakeLists.txt b/src/CMakeLists.txt
index ab9ecd55..4fd4c6af 100644
--- a/src/CMakeLists.txt
+++ b/src/CMakeLists.txt
@@ -27,6 +27,7 @@ set(MPD_SOURCES
 
 set(NETWORK_SOURCES
   ${src_dir}/adapters/net.cpp
+  ${src_dir}/adapters/net_bsd.cpp
   ${src_dir}/modules/network.cpp
   $<IF:$<BOOL:${WITH_LIBNL}>,${src_dir}/adapters/net_nl.cpp,${src_dir}/adapters/net_iw.cpp>
   )
@@ -117,6 +118,8 @@ set(POLY_SOURCES
   ${src_dir}/utils/concurrency.cpp
   ${src_dir}/utils/env.cpp
   ${src_dir}/utils/file.cpp
+  ${src_dir}/utils/gtest_compat.cpp
+  ${src_dir}/utils/acpi.cpp
   ${src_dir}/utils/inotify.cpp
   ${src_dir}/utils/io.cpp
   ${src_dir}/utils/process.cpp
diff --git a/src/adapters/net_bsd.cpp b/src/adapters/net_bsd.cpp
new file mode 100644
index 00000000..df790484
--- /dev/null
+++ b/src/adapters/net_bsd.cpp
@@ -0,0 +1,169 @@
+#if defined(__FreeBSD__)
+
+#include "adapters/net.hpp"
+
+#include <arpa/inet.h>
+#include <ifaddrs.h>
+#include <net/if.h>
+#include <net/if_dl.h>
+#include <netinet/in.h>
+#include <sys/types.h>
+
+#include <cstring>
+
+#include "common.hpp"
+#include "utils/file.hpp"
+#include "utils/string.hpp"
+
+POLYBAR_NS
+
+namespace net {
+  NetType iface_type(const std::string& ifname) {
+    // Quick heuristic: wireless interfaces often show "ssid:" in ifconfig output
+    try {
+      auto out = file_util::contents("/sbin/ifconfig " + ifname);
+      if (string_util::contains(out, "ssid:")) {
+        return NetType::WIRELESS;
+      }
+    } catch (...) {
+      // ignore
+    }
+
+    if (ifname.rfind("lo", 0) == 0) {
+      return NetType::OTHER;
+    }
+
+    return NetType::ETHERNET;
+  }
+
+  bool is_virtual(const std::string&) {
+    // FreeBSD has different sysfs semantics; treat as non-virtual for our purposes
+    return false;
+  }
+
+  std::pair<string, bool> get_canonical_interface(const string& ifname) {
+    int idx = if_nametoindex(ifname.c_str());
+
+    if (idx == 0) {
+      throw system_error("if_nameindex(" + ifname + ")");
+    }
+
+    char canonical[IF_NAMESIZE];
+    if (!if_indextoname(idx, canonical)) {
+      throw system_error("if_indextoname(" + to_string(idx) + ")");
+    }
+
+    string str{canonical};
+
+    return {str, str != ifname};
+  }
+
+  std::string find_interface(NetType type) {
+    struct ifaddrs* ifaddrs_ptr;
+    if (getifaddrs(&ifaddrs_ptr) == -1 || !ifaddrs_ptr) {
+      return "";
+    }
+
+    struct ifaddrs* candidate = nullptr;
+
+    for (struct ifaddrs* i = ifaddrs_ptr; i != nullptr; i = i->ifa_next) {
+      if (!i->ifa_name) continue;
+      const std::string name{i->ifa_name};
+      const NetType iftype = iface_type(name);
+      if (iftype != type) continue;
+      if (candidate == nullptr) {
+        candidate = i;
+      } else if (((candidate->ifa_flags & IFF_RUNNING) == 0) && ((i->ifa_flags & IFF_RUNNING) > 0)) {
+        candidate = i;
+      }
+    }
+
+    if (candidate) {
+      const std::string name{candidate->ifa_name};
+      freeifaddrs(ifaddrs_ptr);
+      return name;
+    }
+
+    freeifaddrs(ifaddrs_ptr);
+    return "";
+  }
+
+  std::string find_wireless_interface() {
+    return find_interface(NetType::WIRELESS);
+  }
+
+  std::string find_wired_interface() {
+    return find_interface(NetType::ETHERNET);
+  }
+
+  bool network::query(bool accumulate) {
+    m_status.previous = m_status.current;
+    m_status.current.transmitted = 0;
+    m_status.current.received = 0;
+    m_status.current.time = std::chrono::steady_clock::now();
+    m_status.ip = NO_IP;
+    m_status.ip6 = NO_IP;
+
+    struct ifaddrs* ifaddr;
+    if (getifaddrs(&ifaddr) == -1 || ifaddr == nullptr) {
+      return false;
+    }
+
+    m_status.mac = NO_MAC;
+
+    for (auto ifa = ifaddr; ifa != nullptr; ifa = ifa->ifa_next) {
+      if (ifa->ifa_addr == nullptr) continue;
+
+      if (m_interface.compare(0, m_interface.length(), ifa->ifa_name) != 0) {
+        if (!accumulate) continue;
+      }
+
+      switch (ifa->ifa_addr->sa_family) {
+        case AF_INET: {
+          char ip_buffer[NI_MAXHOST];
+          getnameinfo(ifa->ifa_addr, sizeof(sockaddr_in), ip_buffer, NI_MAXHOST, nullptr, 0, NI_NUMERICHOST);
+          m_status.ip = string{ip_buffer};
+          break;
+        }
+        case AF_INET6: {
+          char ip6_buffer[INET6_ADDRSTRLEN];
+          auto sa6 = reinterpret_cast<sockaddr_in6*>(ifa->ifa_addr);
+          if (IN6_IS_ADDR_LINKLOCAL(&sa6->sin6_addr)) break;
+          if (IN6_IS_ADDR_SITELOCAL(&sa6->sin6_addr)) break;
+          if ((((unsigned char*)sa6->sin6_addr.s6_addr)[0] & 0xFE) == 0xFC) break;
+          if (inet_ntop(AF_INET6, &sa6->sin6_addr, ip6_buffer, INET6_ADDRSTRLEN) == 0) {
+            m_log.warn("inet_ntop() " + string(strerror(errno)));
+            break;
+          }
+          m_status.ip6 = string{ip6_buffer};
+          break;
+        }
+        case AF_LINK: {
+          auto sdl = reinterpret_cast<struct sockaddr_dl*>(ifa->ifa_addr);
+          if (sdl && sdl->sdl_alen > 0) {
+            unsigned char* mac = reinterpret_cast<unsigned char*>(LLADDR(sdl));
+            char macbuf[32];
+            snprintf(macbuf, sizeof(macbuf), "%02x:%02x:%02x:%02x:%02x:%02x", mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);
+            m_status.mac = string{macbuf};
+          }
+
+          if (ifa->ifa_data != nullptr) {
+            struct if_data* id = reinterpret_cast<struct if_data*>(ifa->ifa_data);
+            m_status.current.transmitted += id->ifi_obytes;
+            m_status.current.received += id->ifi_ibytes;
+          }
+          break;
+        }
+      }
+    }
+
+    freeifaddrs(ifaddr);
+
+    return true;
+  }
+
+} // namespace net
+
+POLYBAR_NS_END
+
+#endif // __FreeBSD__
diff --git a/src/modules/battery.cpp b/src/modules/battery.cpp
index f1ba3b17..8b723fb0 100644
--- a/src/modules/battery.cpp
+++ b/src/modules/battery.cpp
@@ -31,6 +31,49 @@ namespace modules {
     m_interval = m_conf.get<decltype(m_interval)>(name(), "poll-interval", 5s);
     m_lastpoll = chrono::steady_clock::now();
 
+  #if defined(__FreeBSD__)
+    // FreeBSD: use acpiconf/apm fallback (no inotify/sysfs)
+    // State reader: parse output of acpiconf -i 0 or apm
+    m_state_reader = make_unique<state_reader>([] {
+      try {
+        auto out = file_util::contents("/sbin/acpiconf -i 0 2>/dev/null");
+        if (!out.empty()) {
+          auto s = utils::parse_acpiconf_state(out);
+          if (s == "charging") return true;
+          if (s == "discharging") return false;
+          if (s == "ac") return true;
+        }
+        // fallback to apm
+        out = file_util::contents("/sbin/apm 2>/dev/null");
+        if (!out.empty() && out.find("on-line") != string::npos) return true;
+      } catch (...) {
+      }
+      return false;
+    });
+
+    // Capacity reader: parse remaining capacity from acpiconf or apm -l
+    m_capacity_reader = make_unique<capacity_reader>([] {
+      try {
+        auto out = file_util::contents("/sbin/acpiconf -i 0 2>/dev/null");
+        if (!out.empty()) {
+          int v = utils::parse_acpiconf_percent(out);
+          if (v >= 0) return v;
+        }
+        // fallback to apm -l
+        out = file_util::contents("/sbin/apm -l 2>/dev/null");
+        if (!out.empty()) {
+          int v = utils::parse_apm_percent(out);
+          if (v >= 0) return v;
+        }
+      } catch (...) {
+      }
+      return 0;
+    });
+
+    // Rate/consumption best-effort defaults
+    m_rate_reader = make_unique<rate_reader>([] { return 0UL; });
+    m_consumption_reader = make_unique<consumption_reader>([] { return string("0.00"); });
+#else
     auto path_adapter = string_util::replace(PATH_ADAPTER, "%adapter%", m_conf.get(name(), "adapter", "ADP1"s)) + "/";
     auto path_battery = string_util::replace(PATH_BATTERY, "%battery%", m_conf.get(name(), "battery", "BAT0"s)) + "/";
 
@@ -82,6 +125,7 @@ namespace modules {
 
       return 0UL;
     });
+#endif
 
     // Make consumption reader
     m_consumption_reader = make_unique<consumption_reader>([this] {
diff --git a/src/utils/acpi.cpp b/src/utils/acpi.cpp
new file mode 100644
index 00000000..5e5662e4
--- /dev/null
+++ b/src/utils/acpi.cpp
@@ -0,0 +1,60 @@
+#include "utils/acpi.hpp"
+
+#include <cctype>
+#include <sstream>
+
+#include "utils/string.hpp"
+
+POLYBAR_NS
+
+namespace utils {
+  int parse_acpiconf_percent(const std::string& out) {
+    // Look for "Remaining capacity" or "%" after labels
+    auto lc = string_util::lower(out);
+    auto pos = lc.find("remaining capacity");
+    if (pos != std::string::npos) {
+      // Take substring and extract digits
+      std::string tail = out.substr(pos);
+      for (auto &c : tail) if (!std::isdigit(c) && c != '%') c = ' ';
+      std::istringstream iss(tail);
+      int val;
+      while (iss >> val) {
+        if (val >= 0 && val <= 100) return val;
+      }
+    }
+
+    // Fallback: look for percentage sign anywhere
+    for (size_t i = 0; i + 1 < out.size(); ++i) {
+      if (out[i+1] == '%') {
+        // walk backwards to find number
+        size_t j = i;
+        while (j > 0 && std::isdigit(out[j])) --j;
+        std::string num = out.substr(j + (std::isdigit(out[j]) ? 0 : 1), i - j + 1);
+        try {
+          int v = std::stoi(num);
+          if (v >= 0 && v <= 100) return v;
+        } catch (...) {}
+      }
+    }
+
+    return -1;
+  }
+
+  std::string parse_acpiconf_state(const std::string& out) {
+    auto lc = string_util::lower(out);
+    if (lc.find("charging") != std::string::npos) return "charging";
+    if (lc.find("discharging") != std::string::npos) return "discharging";
+    if (lc.find("ac connected") != std::string::npos || lc.find("on-line") != std::string::npos) return "ac";
+    return std::string();
+  }
+
+  int parse_apm_percent(const std::string& out) {
+    // apm -l prints a number between 0 and 100
+    std::istringstream iss(out);
+    int val;
+    if (iss >> val) return val;
+    return -1;
+  }
+}
+
+POLYBAR_NS_END
diff --git a/src/utils/gtest_compat.cpp b/src/utils/gtest_compat.cpp
new file mode 100644
index 00000000..2f4c5feb
--- /dev/null
+++ b/src/utils/gtest_compat.cpp
@@ -0,0 +1,15 @@
+#include <string>
+#include <string_view>
+#include <ostream>
+
+// Compatibility shim for older references to testing::internal::PrintStringTo(std::string, std::ostream*)
+namespace testing {
+namespace internal {
+
+inline void PrintStringTo(const std::string& s, std::ostream* os) {
+  // GTest now provides an overload that accepts basic_string_view; forward to it.
+  PrintStringTo(std::basic_string_view<char>{s}, os);
+}
+
+} // namespace internal
+} // namespace testing
diff --git a/tests/CMakeLists.txt b/tests/CMakeLists.txt
index ccc07e17..32271c18 100644
--- a/tests/CMakeLists.txt
+++ b/tests/CMakeLists.txt
@@ -31,6 +31,15 @@ add_subdirectory(${CMAKE_BINARY_DIR}/googletest-src
 add_custom_target(all_unit_tests
     COMMENT "Building all unit test")
 
+# Small compatibility shim to satisfy older gtest internal symbols (PrintStringTo)
+add_library(gtest_compat STATIC gtest_compat.cpp)
+# Ensure it includes project headers
+get_include_dirs(includes_dir)
+target_include_directories(gtest_compat PRIVATE ${includes_dir} ${CMAKE_CURRENT_LIST_DIR})
+
+target_link_libraries(gtest_compat PRIVATE gtest)
+
+
 function(add_unit_test source_file)
   string(REPLACE "/" "_" testname ${source_file})
   set(name "unit_test.${testname}")
@@ -40,7 +49,7 @@ function(add_unit_test source_file)
   target_include_directories(${name} PRIVATE ${includes_dir} ${CMAKE_CURRENT_LIST_DIR})
 
   # Link against gmock (this automatically links against gtest)
-  target_link_libraries(${name} poly gmock_main)
+  target_link_libraries(${name} poly gmock_main gtest_compat)
   add_test(NAME ${name} COMMAND ${name})
 
   add_dependencies(all_unit_tests ${name})
@@ -57,6 +66,7 @@ add_unit_test(utils/string)
 add_unit_test(utils/file)
 add_unit_test(utils/process)
 add_unit_test(utils/units)
+add_unit_test(utils/acpi)
 add_unit_test(components/builder)
 add_unit_test(components/command_line)
 add_unit_test(components/config_parser)
diff --git a/tests/gtest_compat.cpp b/tests/gtest_compat.cpp
new file mode 100644
index 00000000..83479456
--- /dev/null
+++ b/tests/gtest_compat.cpp
@@ -0,0 +1,23 @@
+// Compatibility shim for older gtest internals
+// Provides testing::internal::PrintStringTo(std::string, ostream*)
+
+#include <ostream>
+#include <string>
+
+namespace testing {
+namespace internal {
+
+// Older Google Test expected `PrintStringTo(std::string, ostream*)`.
+// Newer versions use printing helpers that still allow string streaming,
+// but the symbol might be missing for the link step. Provide a small
+// compatible definition so tests compiling against different gtest
+// versions link successfully.
+
+void PrintStringTo(const std::string& s, std::ostream* os) {
+  if (os) {
+    *os << s;
+  }
+}
+
+} // namespace internal
+} // namespace testing
diff --git a/tests/unit_tests/utils/acpi.cpp b/tests/unit_tests/utils/acpi.cpp
new file mode 100644
index 00000000..45165965
--- /dev/null
+++ b/tests/unit_tests/utils/acpi.cpp
@@ -0,0 +1,25 @@
+#include "gtest/gtest.h"
+#include "utils/acpi.hpp"
+
+using namespace polybar::utils;
+
+TEST(Acpi, parse_acpiconf_percent_basic) {
+  std::string out = "Battery: Remaining capacity: 87%\nSome other info\n";
+  EXPECT_EQ(parse_acpiconf_percent(out), 87);
+}
+
+TEST(Acpi, parse_acpiconf_state) {
+  std::string out = "Battery state: Charging\n";
+  EXPECT_EQ(parse_acpiconf_state(out), "charging");
+
+  out = "Battery state: Discharging\n";
+  EXPECT_EQ(parse_acpiconf_state(out), "discharging");
+
+  out = "AC connected\n";
+  EXPECT_EQ(parse_acpiconf_state(out), "ac");
+}
+
+TEST(Acpi, parse_apm_percent) {
+  std::string out = "75\n";
+  EXPECT_EQ(parse_apm_percent(out), 75);
+}
diff --git a/tests/unit_tests/utils/acpi/CMakeLists.txt b/tests/unit_tests/utils/acpi/CMakeLists.txt
new file mode 100644
index 00000000..2293b7e2
--- /dev/null
+++ b/tests/unit_tests/utils/acpi/CMakeLists.txt
@@ -0,0 +1,3 @@
+add_executable(test_acpi acpi.cpp)
+target_link_libraries(test_acpi PRIVATE poly gtest_main)
+add_test(NAME test_acpi COMMAND test_acpi)
